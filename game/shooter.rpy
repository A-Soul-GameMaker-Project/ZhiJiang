init python:
    screen_height = 532
    screen_width = 945
    ran_speed = 300
    bullet_speed = 400
    dmk_speed = -100

    max_dmk = 30
    # ms
    dmk_inteval_set = (600, 750)
    shoot_inteval = 1000

    total_time = 178

    soul_img_path = "images/jr2.bmp"

    asoul_img_path = "images/jr.png"

    color_list = ["#fffacc", "#c78ae5", "#ffb2d9", "#6b72b3", "#ff6666"]

    bullet_text_ls = ["嘛时候v圈第一啊", "就在今天！", "大家好，我们是asoul", "别吵，这里很关键", "文艺复兴", "大家都好棒！", "好好好！", "完美的团战！", "风情！", "赢完了！", "中国红！", "～(￣▽￣～)～(￣▽￣～)", "座无虚席！", "收到收到收到", "哒哒哒哒哒哒", "有代兄弟们", "雷达全开！", "一刻都不想离开", "鸟巢！！", "鸟巢冲冲", "把鸟巢拿下给你", "去鸟巢吃饭！", "然然生日快乐！", "狂！", "乐乐乐乐乐乐乐乐乐", "00000000000000", "追梦人追梦人", "喜欢喜欢喜欢", "含金量！", "你的舞台太广阔", "太厉害了！", "太棒了太棒了太棒了", "好有元气捏", "拿下拿下", "什么是宅舞二十连的含金量啊", "实力之夜！", "\\嘉然/\\向晚/\\乃琳/\\珈乐/\\贝拉/", "好好好好好好好好好好", "\\嘉然/\\嘉然/\\嘉然/\\嘉然/", "\\向晚/\\向晚/\\向晚/\\向晚/", "\\贝拉/\\贝拉/\\贝拉/\\贝拉/", "\\乃琳/\\乃琳/\\乃琳/\\乃琳/", "\\珈乐/\\珈乐/\\珈乐/\\珈乐/", "\\拉姐/\\拉姐/\\拉姐/", "\\嘉然/\\嘉然/\\嘉然/", "\\晚晚\\晚晚/\\晚晚/", "\\超级的敏感 全与你有关/"]
    dmk_text_ls = ["不想播可以不播", "什么混子", "下播吧", "不喜欢玩就别玩了", "赶紧换人吧", "训粉？训粉？", "就算不想玩也装作想玩吧", "形象塑造必须统一，请演好角色", "卒業しろ卒業しろ", "摆烂是吧摆烂是吧", "你说这个对现状有什么帮助吗", "装不下去了急着下班是吧", "也没亏待你什么，负能量这么满的？", "填弹完毕，锁定目标！", "给我下来", "带节奏第一名", "阴阳观众是吧", "开始折磨了", "这么多前车之鉴看不着是吧", "折磨是吧", "不想播就下播", "别播了，真没效果", "尬住了尬住了", "怎么这么菜呀", "任务完成了，下班吧", "休想逃之夭夭", "rp是吧rp是吧", "然然别拉，等回团体直播想怎么拉就怎么拉", "塔塔开！不战斗就无法生存！", "又在rp又在rp", "戦い戦い", "能别捏嗓子吗？", "冲刺，冲刺，冲", "给你一拳晚晚晚", "差不多下班了", "混够了该下班了！", "这就摆烂了", "【正常弹幕】理解理解", "耍大牌？耍大牌？耍大牌？", "一眼烂", "嬉皮笑脸是吧", "烂烂烂烂烂烂", "我抗不住了，b限再见吧姐姐", "我真顶不住了家人们", "急着下班是吧", "快下班吧快下班吧", "不想播可以不播", "你给我下来", "快进厂吧", "军训观众是吧", "快毕业吧快毕业吧", "试图把我激怒", "道歉道歉道歉", "目力假哭", "那真是太假了呢", "经典假哭", "差不多得了", "黑暗时代来临了", "ttkttkttkttk", "别说了 开哭吧别说了 开哭吧", "混子来了混子来了", "混混混混混混混混", "又摆烂咯"]

    xw_img_ls = [
        'images/meta/xw/1.bmp',
        'images/meta/xw/2.bmp',
        'images/meta/xw/3.bmp',
        'images/meta/xw/4.bmp',
        'images/meta/xw/5.bmp',
        'images/meta/xw/6.bmp',
    ]

    jl_img_ls = [
        'images/meta/jl/1.bmp',
        'images/meta/jl/2.bmp',
        'images/meta/jl/3.bmp',
        'images/meta/jl/4.bmp',
        'images/meta/jl/5.bmp',
        'images/meta/jl/6.bmp',
        'images/meta/jl/7.bmp',
        'images/meta/jl/8.bmp',
    ]

    nl_img_ls = [
        'images/meta/nl/1.bmp',
        'images/meta/nl/2.bmp',
        'images/meta/nl/3.bmp',
        'images/meta/nl/4.bmp',
    ]

    jr_img_ls = [
        'images/meta/jr/1.bmp',
        'images/meta/jr/2.bmp',
        'images/meta/jr/3.bmp',
        'images/meta/jr/4.bmp',
        'images/meta/jr/5.bmp',
        'images/meta/jr/6.bmp',
        'images/meta/jr/7.bmp',
        'images/meta/jr/8.bmp',
        'images/meta/jr/9.bmp',
    ]

    bl_img_ls = [
            'images/meta/bl/1.bmp',
            'images/meta/bl/2.bmp',
            'images/meta/bl/3.bmp',
            'images/meta/bl/4.bmp',
            'images/meta/bl/5.bmp',
            'images/meta/bl/6.bmp',
            'images/meta/bl/5.bmp',
            'images/meta/bl/4.bmp',
            'images/meta/bl/3.bmp',
            'images/meta/bl/2.bmp',
            'images/meta/bl/1.bmp',
    ]

    soul_img_ls = [
        'images/meta/soul/1.bmp',
        'images/meta/soul/2.bmp',
        'images/meta/soul/3.bmp',
        'images/meta/soul/4.bmp',
        'images/meta/soul/5.bmp',
        'images/meta/soul/6.bmp',
        'images/meta/soul/7.bmp',
        'images/meta/soul/8.bmp',
    ]

init python:

    class ShooterActor:
        def __init__(self, displayable, speed=(0, 0), start=(0, 0)):
            # super(ShooterActor, self).__init__(*args, **kwargs)

            self.displayable = displayable

            self.speed_x = 0
            self.speed_y = 0

            self.max_speed_x = speed[0]
            self.max_speed_y = speed[1]

            self.start_x = start[0]
            self.start_y = start[1]

            self.x = start[0]
            self.y = start[1]

            self.old_st = None
            self.displayable_render = None

            self.alive = True

        def update(self, width, height, st, at):
            pass

        def update_displayable_render(self, width, height, st, at):
            self.displayable_render = renpy.render(self.displayable, width, height, st, at)

        @property
        def width(self):
            try:
                return self.displayable_render.get_size()[0]
            except AttributeError:
                return 0

        @property
        def height(self):
            try:
                return self.displayable_render.get_size()[1]
            except AttributeError:
                return 0

        def handle_collision(self):
            pass

        def collision_with(self, other):

            left = self.x
            right = self.x + self.width
            top = self.y
            bottom = self.y + self.height

            other_left = other.x
            other_right = other.x + other.width
            other_top = other.y
            other_bottom = other.y + other.height

            horizontal_hit = False
            vertical_hit = False


            if (left >= other_left) and (left <= other_right):
                horizontal_hit = True

            if (right >= other_left) and (right <= other_right):
                horizontal_hit = True

            if not horizontal_hit:
                return False

            if (top >= other_top) and (top <= other_bottom):
                vertical_hit = True

            if (bottom >= other_top) and (bottom <= other_bottom):
                vertical_hit = True

            if not vertical_hit:
                return False

            self.handle_collision()
            return True


init python:
    from random import randint, choice, shuffle

    class Danmaku(ShooterActor):
        def __init__(self, dmk_text, start_loc_x=screen_width, start_loc_y=None):
            super(Danmaku, self).__init__(
                Text(dmk_text, style="dmk_outline"), 
                (dmk_speed, 0), 
                (start_loc_x, start_loc_y if start_loc_y else randint(0, screen_height - 80)))

        def handle_collision(self):
            pass

        def update(self, width, height, st, at):
            if self.old_st is None:
                self.old_st = st

            dtime = st - self.old_st
            self.old_st = st

            speed_x = dtime * self.max_speed_x
            speed_y = dtime * self.max_speed_y

            self.x += speed_x
            self.y += speed_y

            self.update_displayable_render(width, height, st, at)

init python:
    class Bullet(ShooterActor):
        def __init__(self, bullet_text, original_position, speed=(bullet_speed, 0)):
            super(Bullet, self).__init__(
                Text(bullet_text, color=choice(color_list), style="dmk_outline"), speed, original_position)

        def handle_collision(self):
            pass

        def update(self, width, height, st, at):
            if self.old_st is None:
                self.old_st = st

            dtime = st - self.old_st
            self.old_st = st

            speed_x = dtime * self.max_speed_x
            self.x += speed_x

            if self.x >= screen_width:
                self.alive = False
            self.update_displayable_render(width, height, st, at)

init python:
    import pygame

    right_key_list = [pygame.K_RIGHT, pygame.K_d]
    left_key_list = [pygame.K_LEFT, pygame.K_a]

    up_key_list = [pygame.K_UP, pygame.K_w]
    down_key_list = [pygame.K_DOWN, pygame.K_s]

    class Player(ShooterActor):
        def __init__(self, character):
            super(Player, self).__init__(character, (ran_speed, ran_speed))
            # super(Player, self).__init__(ASoul([soul_img_path]), (ran_speed, ran_speed), (175, 250))

            self.rect = renpy.load_surface(self.displayable.img).get_rect()

            self.x = self.displayable.x
            self.y = self.displayable.y

            self.h_moving = []
            self.v_moving = []

        def handle_collision(self):
            pass

        def update(self, width, height, st, at):
            if self.old_st is None:
                self.old_st = st

            dtime = st - self.old_st
            self.old_st = st

            self.move_player(dtime)

            self.update_displayable_render(width, height, st, at)
            self.displayable.update_img(st)

        def update_displayable_render(self, width, height, st, at):
            if self.width != 0 and self.height != 0:
                self.displayable_render = renpy.render(self.displayable.img, self.width, self.height, st, at)
            else:
                self.displayable_render = renpy.render(self.displayable.img, width, height, st, at)

        def move_player(self, dtime):
            speed_x = 0
            speed_y = 0
            if len(self.h_moving) != 0:
                speed_x = dtime * self.max_speed_x

            if len(self.v_moving) != 0:
                speed_y = dtime * self.max_speed_y

            if len(self.v_moving) != 0 and len(self.h_moving) != 0:
                speed_y *= 0.707
                speed_x *= 0.707

            if speed_x != 0:
                if self.x + 30 < screen_width and self.h_moving[0] == 'r':
                    self.x += speed_x
                if self.x > 120 and self.h_moving[0] == 'l':
                    self.x -= speed_x

            if speed_y != 0:
                if self.y + 70 < screen_height and self.v_moving[0] == 's':
                    self.y += speed_y
                if self.y > 0 and self.v_moving[0] == 'w':
                    self.y -= speed_y


        def handle_key_down(self, event):
            if event.key in right_key_list:
                if 'r' not in self.h_moving:
                    self.h_moving.append('r')

            elif event.key in left_key_list:
                if 'l' not in self.h_moving:
                    self.h_moving.append('l')

            elif event.key in up_key_list:
                if 'w' not in self.v_moving:
                    self.v_moving.append('w')

            elif event.key in down_key_list:
                if 's' not in self.v_moving:
                    self.v_moving.append('s')

        def handle_key_up(self, event):
            if event.key in right_key_list and 'r' in self.h_moving:
                self.h_moving.remove('r')

            elif event.key in left_key_list and 'l' in self.h_moving:
                self.h_moving.remove('l')

            elif event.key in up_key_list and 'w' in self.v_moving:
                self.v_moving.remove('w')

            elif event.key in down_key_list and 's' in self.v_moving:
                self.v_moving.remove('s')

        @property
        def width(self):
            return self.rect.width

        @property
        def height(self):
            return self.rect.height



init python:
    class ASoul:
        def __init__(self, img_ls, x=0, y=0):
            self.x = x
            self.y = y

            self.img_ls = [im.FactorScale(i, 0.7, 0.7) for i in img_ls]

            self.length = len(self.img_ls)

            self.last_time = 0

            self.count = 0

            self.img = self.img_ls[0]

        def update_img(self, st):
            if self.length == 1:
                return

            if st - self.last_time < 0.2:
                return
            self.count += 1
            self.count %= self.length

            self.last_time = st

            self.img = self.img_ls[self.count]

init python:
    import threading
    import math
    from random import randint, choice
    import pygame

    class GameBoard(renpy.Displayable):
        def __init__(self, name):
            super(GameBoard, self).__init__()
            pygame.event.set_allowed([pygame.KEYDOWN, pygame.KEYUP, pygame.USEREVENT])
            self.max_dmk = max_dmk

            self.player_name = Text(name, style="dmk_outline")
            self.name = name

            self.dmk_list = []


            self.bullets = []

            self.time_all = total_time  # 总时长，单位秒
            self.time_now = 0

            self.time_slice = [0.07, 0.2, 0.3, 0.8, 2]  # 不同阶段的变化时间点
            self.bullet_num = [1, 2, 3, 5, 8]  # 不同阶段的子弹并排数目

            self.y_position = [0]
            self.init_y_position()

            self.count = 0

            # 发射弹幕子弹的计数器
            self.old_shoot = 0
            self.shoot_inteval = shoot_inteval / 1000
            self.old_dmk = 0
            self.dmk_inteval = float(randint(*dmk_inteval_set)) / 1000

            self.characters = [
                ASoul(xw_img_ls, 20, 15),
                ASoul(jr_img_ls, 12, 100),
                ASoul(nl_img_ls, 40, 200),
                ASoul(jl_img_ls, 20, 300),
                ASoul(bl_img_ls, 12, 400),
            ]

            character = ASoul(soul_img_ls, 130, 220)
            nameOffset = (10, 70)
            if name == "向晚":
                character = self.characters.pop(0)
                nameOffset = (15, 75)

            if name == "嘉然":
                character = self.characters.pop(1)
                nameOffset = (20, 85)

            if name == "乃琳":
                character = self.characters.pop(2)
                nameOffset = (0, 85)
            if name == "珈乐":
                character = self.characters.pop(3)
                nameOffset = (15, 85)

            if name == "贝拉":
                character = self.characters.pop(4)
                nameOffset = (20, 85)
            self.nameOffset = nameOffset
            self.player = Player(character)

            self.side = Solid("#63517399", xsize=120, ysize=532)


        def init_y_position(self):
            num = max(self.bullet_num)

            for i in range(1, num):
                self.y_position.append(i)
                self.y_position.append(-i)

        def check_collisions(self):
            for enemy in self.dmk_list:
                if not enemy.alive:
                    continue

                for bullet in self.bullets:
                    if bullet.collision_with(enemy):
                        enemy.alive = False
                        bullet.alive = False


        def render(self, width, height, st, at):
            self.time_now = st
            render = renpy.Render(width, height)

            if st >= total_time:
                my_event = pygame.event.Event(pygame.USEREVENT)
                pygame.event.post(my_event)
                return render

            for item in self.bullets:
                if not item.alive:
                    self.bullets.remove(item)
            for item in self.dmk_list:
                if item.x <= 120:
                    self.count += 1
                    item.alive = False

                if not item.alive:
                    self.dmk_list.remove(item)


            self.check_shoot()
            self.check_dmk()
            self.check_collisions()


            count = renpy.render(Text("受击: " + str(self.count), style="dmk_outline"), 150, 50, st, at)
            render.blit(count, (10, screen_height - 40))

            side = renpy.render(self.side, 150, 660, st, at)
            render.blit(side, (0, 0))

            self.player.update(width, height, st, at)
            render.blit(self.player.displayable_render, (self.player.x, self.player.y))

            name = renpy.render(self.player_name, 120, 70, st, at)
            render.blit(name, (self.player.x + self.nameOffset[0], self.player.y + self.nameOffset[1]))


            for inx, item in enumerate(self.characters):
                item.update_img(st)
                r = renpy.render(item.img, width, height, st, at)
                render.blit(r, (item.x, item.y) )


            for bullet in self.bullets:
                bullet.update(width, height, st, at)
                render.blit(bullet.displayable_render, (bullet.x, bullet.y))

            for dmk in self.dmk_list:
                dmk.update(width, height, st, at)
                render.blit(dmk.displayable_render, (dmk.x, dmk.y))

            renpy.redraw(self, 0)
            return render

        def generate_bullets(self):
            def delay_shoot(text, _i, _bias):
                new_bullet = Bullet(text,(self.player.x + 80, self.player.y + self.y_position[_i] * _bias + 30))
                pygame.time.delay(randint(0, 300))
                self.bullets.append(new_bullet)


            progress = self.time_now / self.time_all
            now_slice = 0

            for i in range(len(self.time_slice)):
                if progress <  self.time_slice[i]:
                    now_slice = i
                    break

            bias = 30  # 改

            bullets_num = self.bullet_num[now_slice]

            for i in range(bullets_num):
                t = threading.Thread(target=delay_shoot, args=(choice(bullet_text_ls), i, bias, ))
                t.start()

        def event(self, event, x, y, st):
            if self.time_now >= total_time:
                if self.count <= 3:
                    achievement.grant('protect')
                return 0

            if event.type == pygame.KEYDOWN:
                self.player.handle_key_down(event)

            if event.type == pygame.KEYUP:
                self.player.handle_key_up(event)
            raise renpy.IgnoreEvent()

        def check_shoot(self):
            if self.time_now - self.old_shoot > self.shoot_inteval:
                self.generate_bullets()
                self.old_shoot = self.time_now

        def check_dmk(self):
            if self.time_now - self.old_dmk > self.dmk_inteval:
                dmk_num = len(self.dmk_list)
                if dmk_num >= self.max_dmk:
                    return
                text = choice(dmk_text_ls)
                dmk = Danmaku(text)
                self.dmk_list.append(dmk)
                self.old_dmk = self.time_now
                self.dmk_inteval = float(randint(*dmk_inteval_set)) / 1000


style dmk_outline:
    outlines [ (1, "#000000", 0, 0 ) ]


init python:
    from random import randint, choice
    class DMK:
        def __init__(self, txt,x,level, haveColor):
            if haveColor:
                dice = randint(0,9)
                if dice < 6:
                    self.dmk = Text(txt, style='dmk_outline')
                elif dice < 8:
                    self.dmk = Text(txt, style='dmk_outline', color = '#52eed8')
                elif dice < 9:
                    self.dmk = Text(txt, style='dmk_outline', color = '#58c1de')
                else:
                    self.dmk = Text(txt, style='dmk_outline', color = '#e33fff')
            else:
                self.dmk = Text(txt, style='dmk_outline')
            self.x = x
            self.y = level * 27 - 4
            self.len = len(txt) * 25
            self.alive = True
            self.level = level

    class DmkScreen(renpy.Displayable):
        def __init__(self, inteval_set=(400, 600), max_dmk=50, mode='loop', haveColor = False):
            super(DmkScreen, self).__init__()
            self.dmk_list = []

            self.mode = mode

            self.inteval_set = inteval_set

            self.dmk_inteval = float(randint(*inteval_set)) / 1000

            self.max_dmk = max_dmk
            self.old_dmk = 0
            self.time_now = 0
            self.idle = {}
            self.haveColor = haveColor
            for i in range(20):
                self.idle[i] = True

        def check_collisions(self):
            for dmk in self.dmk_list:
                if dmk.x + dmk.len <= 0:
                    dmk.alive = False

                if not dmk.alive:
                    self.dmk_list.remove(dmk)
                    

        def event(self, event, x, y, st):
            if len(tmp_dmk_list) == 0:
                return 0

        def check_dmk(self):
            if len(tmp_dmk_list) == 0:
                return

            if self.time_now - self.old_dmk > self.dmk_inteval:
                dmk_num = len(self.dmk_list)

                if dmk_num >= self.max_dmk:
                    return

                if self.mode == 'loop':
                    text = choice(tmp_dmk_list)
                elif self.mode == 'pop':
                    text = tmp_dmk_list.pop()
                    if text[-1] == '.':
                        tmp_dmk_list.remove(text)
                level = randint(0, 19)
                dmk = DMK(text, 1600, level, self.haveColor)
                if self.idle[level]:
                    self.dmk_list.append(dmk)
                self.old_dmk = self.time_now
                self.dmk_inteval = float(randint(*self.inteval_set)) / 1000

        def update(self, dmk, dtime):
            dmk.x += dtime * dmk_speed

        def render(self, width, height, st, at):
            dtime = st - self.time_now
            self.time_now = st
            render = renpy.Render(width, height)

            if len(tmp_dmk_list) == 0:
                my_event = pygame.event.Event(pygame.USEREVENT)
                pygame.event.post(my_event)
                return render
            
            self.check_collisions()

            self.check_dmk()

            for i in range(20):
                self.idle[i] = True

            for dmk in self.dmk_list:
                self.update(dmk, dtime)
                if (dmk.x + dmk.len + 25) > 1600:
                    self.idle[dmk.level] = False
                r = renpy.render(dmk.dmk, width, height, st, at)
                render.blit(r, (dmk.x, dmk.y))
            
            renpy.redraw(self, 0)
            return render


init python:
    tmp_dmk_list = []


screen dmk_screen(inteval_set=(400, 600), max_dmk=50, mode='loop', haveColor = False):
    modal False
    default dmk_board = DmkScreen(inteval_set, max_dmk, mode, haveColor)
    fixed:
        xpos 0
        ypos 0
        add dmk_board

